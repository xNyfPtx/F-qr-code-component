{"version":3,"file":"organize.js","sourceRoot":"","sources":["../src/organize.ts"],"names":[],"mappings":"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","sourcesContent":["export const DEFAULT_GROUP = \"$DEFAULT\";\n\nexport type GroupQuery = string | RegExp;\nexport type GroupKey<TPresets extends Presets> =\n  | keyof TPresets\n  | string\n  | typeof DEFAULT_GROUP;\n\nexport type Presets = Record<string, GroupQuery | GroupQuery[]>;\n\nexport type OrganizedGroup<TValue> = { values: TValue[]; query: GroupQuery };\nexport type OrganizedResult<TValue> = {\n  groups: OrganizedGroup<TValue>[];\n  flat: TValue[];\n};\n\nexport interface BaseOrganizeOptions<TPresets extends Presets> {\n  presets?: TPresets;\n  groups: GroupKey<TPresets>[];\n  sort?: OrganizeOptionsSort;\n  ignoreCase?: boolean;\n}\n\nexport type OrganizeOptionsSort = \"ASC\" | \"DESC\" | boolean;\nexport interface MapOrganizeOptions<TPresets extends Presets, TValue>\n  extends BaseOrganizeOptions<TPresets> {\n  map: (value: TValue) => string;\n}\n\nexport type OrganizeOptions<TPresets extends Presets, TValue> =\n  | BaseOrganizeOptions<TPresets>\n  | MapOrganizeOptions<TPresets, TValue>;\n\nexport function miniorganize<TPresets extends Presets>(\n  values: string[],\n  options: BaseOrganizeOptions<TPresets>\n): OrganizedResult<string>;\nexport function miniorganize<TPresets extends Presets, TValue>(\n  values: TValue[],\n  options: MapOrganizeOptions<TPresets, TValue>\n): OrganizedResult<TValue>;\nexport function miniorganize<TValue>(\n  values: TValue[],\n  options: OrganizeOptions<Presets, TValue>\n): OrganizedResult<TValue> {\n  const getGroups = (\n    query: GroupQuery\n  ): {\n    regexp?: RegExp;\n    unknown: boolean;\n    values: TValue[];\n    query: GroupQuery;\n  }[] => {\n    if (query === DEFAULT_GROUP) {\n      return [getDefaultGroup()];\n    }\n\n    const preset = typeof query === \"string\" && options.presets?.[query];\n    if (!preset) {\n      return [\n        {\n          regexp: groupQueryToRegExp(query, !!options.ignoreCase),\n          unknown: false,\n          values: [],\n          query,\n        },\n      ];\n    }\n\n    return Array.isArray(preset)\n      ? preset.flatMap(getGroups)\n      : getGroups(preset);\n  };\n\n  const groups = options.groups.flatMap(getGroups);\n\n  let defaultGroup = groups.find((group) => group.unknown);\n  if (!defaultGroup) {\n    defaultGroup = getDefaultGroup();\n    groups.push(defaultGroup);\n  }\n\n  const getString = (value: TValue): string => {\n    if (\"map\" in options) {\n      return options.map(value);\n    } else if (typeof value === \"string\") {\n      return value;\n    } else {\n      throw Error(\"Neither a map function nor string values were passed!\");\n    }\n  };\n\n  values.forEach((value) => {\n    const mapped = getString(value);\n\n    for (let group of groups) {\n      if (group.regexp && mapped.match(group.regexp)) {\n        group.values.push(value);\n        return;\n      }\n    }\n\n    defaultGroup!.values.push(value);\n  });\n\n  if (options.sort) {\n    groups.forEach((group) => {\n      group.values.sort((a, b) => getString(a).localeCompare(getString(b)));\n\n      if (options.sort === \"DESC\") {\n        group.values.reverse();\n      }\n    });\n  }\n\n  return {\n    flat: groups.flatMap((group) => group.values),\n    groups: groups.map(({ query, values }) => ({ query, values })),\n  };\n}\n\nfunction groupQueryToRegExp(query: GroupQuery, ignoreCase: boolean): RegExp {\n  let flags = \"\";\n\n  if (ignoreCase) {\n    flags += \"i\";\n  }\n\n  return new RegExp(query, flags);\n}\n\nfunction getDefaultGroup() {\n  return {\n    unknown: true,\n    values: [],\n    query: DEFAULT_GROUP,\n  };\n}\n"]}